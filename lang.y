/***************************************************************************/
/*

   This file, along with the langlex.c and langlex.l, are extensions of the TP's files.

   This program is an example implementation of the level-3 objective, which involves exploring all reachable states and checking them against reachability specifications.
   
   It is written in Yacc/Bison, which is a tool for generating parsers and grammars. The grammar is in the file lang.y, and the lexical analyzer is in the file langlex.c. The lexical analyzer is generated by the tool Flex, which is a lexical analyzer generator.

   To compile the program, first run "make langlex.c" and then "make lang".

   The parsing (creation of the tree) is the first step.

*/
/***************************************************************************/

/****************************************************************************/
%{
//Definition of key structures and their initialization functions.
//The %{ and %} are used to include C code in the Bison file.
/****************************************************************************/

// Include necessary header files and declare external functions
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern int yylex();
extern int yylineno;

// Function to display error messages during parsing
void yyerror(char *s)
{
	fflush(stdout);
	fprintf(stderr, "%s near line %d\n",s,yylineno);
	exit(1);
}

// A structure for storing variables and their values
typedef struct var
{
	char *name; // Variable name
	long value; // Current value of the variable
	struct var *next; // Pointer to the next variable in the list
} var;

// A structure for storing expressions used in assignments, guards, and specs
typedef struct expr
{
	int type; // Operator type
	struct expr *left, *right; // Left and right subexpressions
		// For constants and idents, the 'left' field is used
	int sat; // Reachability of the expression, initialized at 0
	struct expr *next; // Pointer to the next expression in the list
} expr;

// A structure for storing each process in the program
typedef struct process
{
	char *name; // Process name
	var *locals; // Local variables
	struct stmt *block; // Pointer to the first statement in the process
	struct stmt *current; // Pointer to the current statement, for computing reachability
	struct process *next; // Pointer to the next process in the list
} process;

// A structure for storing sequences of statements
typedef struct stmt
{
	int type; // Statement type (e.g. assignment, do, if, break, skip)
	var *var; // Variable used in the statement (e.g. for assignment)
	expr *expr; // Expression used in the statement (e.g. for assignment)
	struct choice *choice; // Pointer to a choice structure, used in do and if statements
	struct stmt *up; // Pointer to the enclosing do or if statement
	struct stmt *next; // Pointer to the next statement in the sequence
} stmt;

// A structure for storing choices in a do or if statement
typedef struct choice
{
	expr *guard; // Guard expression, if NULL then the choice is ELSE
	struct stmt *block; // Subordinate statements to be executed if the guard is true
	struct choice *next; // Pointer to the next choice in the list
} choice;

// All data pertaining to the program are accessible from these four vars.
var     *global_vars; // Pointer to the list of global variables
var	*local_vars; // Pointer to the list of local variables
process	*global_procs; // Pointer to the list of processes
expr	*global_specs; // Pointer to the list of expressions used in reachability specs

// To compute all reachable states, we need to know the size of a state in bytes,
// which includes space for the current statements of each process and for all variables.
int state_size = 0;

// Function to create a new variable
var* make_ident (char *s)
{
	var *v = malloc(sizeof(var)); // Allocate memory for the pointer to the new variable
	v->name = s;
	v->value = 0;	// All variables are initialized to 0
	v->next = NULL; // The new variable is added to the end of the list
	state_size += sizeof(v->value);
	return v;
}

// Function to find a variable in a given variable list
var* find_ident_in (char *s,var *varlist)
{
	while (varlist && strcmp(varlist->name,s)) varlist = varlist->next;
	return varlist;
}

// Function to find a variable in the global and local variable lists
var* find_ident (char *s)
{
	var *v = find_ident_in(s,local_vars);
	if (!v) v = find_ident_in(s,global_vars);
	if (!v) yyerror("variable not found");
	return v;
}

/***************************************************************/
/* Initialization of useful structures to make the program run */

// Function to create a new process
// The process is added to the end of the list of processes
// This is usefull when several processes are defined in the same program
process* make_process (char *s, var *locals, stmt *block)
{
	process *p = malloc(sizeof(process));
	p->name = s;
	p->locals = locals;
	p->block = block;
	p->current = block;
	p->next = NULL;
	state_size += sizeof(p->current);
	return p;
}

// Function to create a new expression
expr* make_expr (int type, expr *left, expr *right)
{
	expr *e = malloc(sizeof(expr));
	e->type = type;
	e->left = left;
	e->right = right;
	e->sat = 0;
	e->next = NULL;
	return e;
}

// Function to create a new choice
choice* make_choice (expr *guard, stmt *block)
{
	choice *c = malloc(sizeof(choice));
	c->guard = guard;
	c->block = block;
	c->next = NULL;
	return c;
}

// Function to create a new statement
stmt* make_stmt (int type, var *var, expr *expr, choice *choice)
{
	stmt *s = malloc(sizeof(stmt));
	s->type = type;
	s->var = var;
	s->expr = expr;
	s->choice = choice;
	s->next = NULL;
	s->up = NULL;
	return s;
}

// Function to set the "up" pointer of statements inside a DO/IF block
// It follows the chain of statements in one direction of the block and sets the
// of each statement to the enclosing DO/IF statement "up" pointer
void up_stmt (stmt *block, stmt *s)
{
	while (block) { block->up = s; block = block->next; }
}

// Function to set the "up" pointer of choices inside a DO/IF block
void up_choices (choice *c, stmt *s)
{
	while (c) { up_stmt(c->block,s); c = c->next; }
}

/****************************************************************************/
// End of useful structures initialization
%}
/****************************************************************************/

// Use union to define types for terminals and non-terminals
%union {
	char *c; // String
	long i; // Integer
	expr *e; // Expression
	stmt *s; // Statement
	var *v; // Variable
	choice *x; // Choice
	process *p; // Process
}

%type <e> expr specs
%type <s> stmt stmts
%type <x> choice choices
%type <v> vars varlist
%type <p> procs process

// Define the terminals
%token VAR PROC END DO OD IF FI ELSE BREAK REACH SKIP
%token COLONS ARROW ASSIGN EQ AND OR NOT
%token <c> IDENT
%token <i> INT

// Define the precedence and associativity of operators
%left ';'
%left EQ
%left '<' '>'
%left OR
%left AND
%left '+' '-'
%left '*'
%right NOT

/****************************************************************************/
%%
// The %% section is used to declare the rules of the grammar
// This defines the syntax of the language
/****************************************************************************/

/* Here, we use mid-rule actions provided by Bison.
 * In Bison, a grammar rule consists of a left-hand side (the symbol being defined) and a
 * right-hand side (the sequence of symbols that can derive the left-hand side).
 * Mid-rule actions allow you to perform some actions or computations in the middle of a
 * rule's right-hand side.
 *
 * For example :
 *  After parsing the "procs" symbol, the mid-rule action
        { global_procs = $3; local_vars = NULL; }
    is executed. It assigns the value of $3 (the attribute of the "procs" symbol) to
    global_procs and sets local_vars to NULL.
 * The same goes on for the other mid-rule actions.
*/

start	: vars  { global_vars = $1; } // When parsing starts, we first define the variables (if any)
	  procs { global_procs = $3; local_vars = NULL; } // Then proceed with the processes
	  specs { global_specs = $5; } // Finally, add specifications

vars	: { $$ = NULL; } // Initial case: No variables
	| VAR varlist ';' vars // Variables in the following format VAR ident1, ident2 ... ;
	  {
		var *tmp = $2;
		while (tmp->next) tmp = tmp->next;
		tmp->next = $4;
		$$ = $2;
	  }
		
varlist	: IDENT			{ $$ = make_ident($1); } // List of variable identifiers
	| varlist ',' IDENT	{ ($$ = make_ident($3))->next = $1; }

procs	: process // Initial case: one process
	| procs process		{ ($$ = $2)->next = $1; } // Add more processes

process : PROC IDENT vars	{ local_vars = $3; } // Start with process name and variables
	  stmts END		{ $$ = make_process($2,local_vars,$5); } // End with the process statement

stmts	: stmt // The statement can be alone
	| stmt ';' stmts	{ ($$ = $1)->next = $3; } // Or multiple statements separated by SEMICOLON

stmt	: IDENT ASSIGN expr //Assignment statement
		{ $$ = make_stmt(ASSIGN,find_ident($1),$3,NULL); }
	| DO choices OD //DO clause
		{ $$ = make_stmt(DO,NULL,NULL,$2); up_choices($2,$$); }
	| IF choices FI //IF clause
		{ $$ = make_stmt(IF,NULL,NULL,$2); up_choices($2,$$); }
	| BREAK //Break clause
		{ $$ = make_stmt(BREAK,NULL,NULL,NULL); }
	| SKIP //Skip clause
		{ $$ = make_stmt(SKIP,NULL,NULL,NULL); }

choices	: choice // The choice can be one choice statement
	| choice choices // Or more than one choice statement
		{ ($$ = $1)->next = $2;
		  if ($1->guard == NULL && $2 != NULL)
			yyerror("The ELSE statement must be last choice in DO/IF"); }

choice	: COLONS expr ARROW stmts	{ $$ = make_choice($2,$4); } // Choice with guard
	| COLONS ELSE ARROW stmts	{ $$ = make_choice(NULL,$4); } // Choice without guard

expr	: IDENT		{ $$ = make_expr(IDENT,(expr*)find_ident($1),NULL); } // Variable
	| expr '+' expr	{ $$ = make_expr('+',$1,$3); } // Add expression
	| expr '-' expr	{ $$ = make_expr('-',$1,$3); } // Subtraction expression
	| expr '*' expr	{ $$ = make_expr('*',$1,$3); } // Multiplication expression
	| expr '<' expr	{ $$ = make_expr('>',$3,$1); } // Less than expression
	| expr '>' expr	{ $$ = make_expr('>',$1,$3); } // Greater than expression
	| expr EQ expr	{ $$ = make_expr(EQ,$1,$3); } // Equality expression
	| NOT expr	{ $$ = make_expr(NOT,$2,NULL); } // Negative expression
	| expr AND expr	{ $$ = make_expr(AND,$1,$3); } // AND expression
	| expr OR expr	{ $$ = make_expr(OR,$1,$3); } // OR expression
	| INT		{ $$ = make_expr(INT,(expr*)$1,NULL); } // Integer
	| '(' expr ')'	{ $$ = $2; } // Parenthetical expression

specs	: 			{ $$ = NULL; } // Initial case: No specifications
	| REACH expr specs	{ ($$ = $2)->next = $3; } // Add Reachability Specifications


/****************************************************************************/
// End of the %% section. This is it for the syntax of the language.
%%
/****************************************************************************/

// TODO : comment from here on

#include "langlex.c"

/* Interface with hash table: saving and restoring states                   */

// The "current" state is defined by
//  (i) instruction pointers of each process (p->current in global_procs)
//  (ii) values of global and local variables.
// To save a state, we copy this information into a wState structure to be
// stored in the hash table. To restore a state, we copy it back.

#include "hash.c"
#include "crc32.c"

wHash *hash;

// The hashtable needs a function to order the states, and here it is.
int cmp_states (wState* state1, wState* state2)
	{ return memcmp(state1->memory, state2->memory, state_size); }

// save_state and restore_state are used as arguments of copy_state to decide what to do with the variables of a given state
void save_state (void **mem, void *ptr, int size)
	{ memcpy(*mem,ptr,size); *mem += size; }

void restore_state (void **mem, void *ptr, int size)
	{ memcpy(ptr,*mem,size); *mem += size; }

// This function takes a pointer to a state and whether it should save the current process's memory inside of it, or restore the state's memory inside the process.
void copy_state (wState *s, void (*copyfn)(void**,void*,int))
{
	void *tmp = s->memory;
	for (process *p = global_procs; p; p = p->next)
	{
		copyfn(&tmp,&(p->current),sizeof(process*));
		for (var *v = p->locals; v; v = v->next)
			copyfn(&tmp,&(v->value),sizeof(long));
	}
	for (var *v = global_vars; v; v = v->next)
		copyfn(&tmp,&(v->value),sizeof(long));
}

// Creation of a new state from the current one, and insertion into the hash table if it is not already visited.
void add_state ()
{
	// generate the new structure to be inserted in the hash table
	wState *s = malloc(sizeof(wState));
	s->memory = malloc(state_size);
	copy_state(s,save_state);
	s->hash = xcrc32(s->memory,state_size,0xffffffff);

	// check whether state already known, free memory if so
	wState *t = wHashInsert(hash,s);
	if (s == t) return;
	free(s->memory);
	free(s);
}

// Restore current state from hashed state
void restore_state (wState *s) { copy_state(s,restore_state); }


/****************************************************************************/
/* These functions implement the semantics of the language.                 */

// evaluate an integer expression (assign/guard/spec)
int eval (expr *e)
{
	switch (e->type)
	{
		case OR: return eval(e->left) || eval(e->right);
		case AND: return eval(e->left) && eval(e->right);
		case NOT: return !eval(e->left);
		case EQ: return eval(e->left) == eval(e->right);
		case '>': return eval(e->left) > eval(e->right);
		case '+': return eval(e->left) + eval(e->right);
		case '*': return eval(e->left) * eval(e->right);
		case '-': return eval(e->left) - eval(e->right);
		case IDENT: return ((var*)(e->left))->value;
		case INT: return (long)(e->left);
	}
}

// Given process p, find next statement after p->current
void to_next (process *p)
{
	// find nearest containing block with a successor
	while (p->current && !p->current->next) p->current = p->current->up;

	// p->current is now NULL, DO, or IF
	if (!p->current) return;
	if (p->current->type == DO) return;
	p->current = p->current->next;
}

// same as to_next but when current statement is BREAK
void do_break (process *p)
{
	// find nearest including DO structure
	while (p->current && p->current->type != DO)
		p->current = p->current->up;

	// if break outside DO, terminate p
	if (!p->current) return;

	// break out of DO to 'next' or 'up' statement
	if (p->current->next)
		{ p->current = p->current->next; }
	else
		{ p->current = p->current->up; to_next(p); } 
}

// for DO/IF, identify all satisfied guards and go into them
void do_choices (process *p)
{
	int els = 1;	// can take ELSE branch unless another guard is true

	for (choice *c = p->current->choice; c; c = c->next)
	{
		if (!c->guard && !els) continue;
		if (c->guard && !eval(c->guard)) continue;

		p->current = c->block;
		add_state();
		els = 0;
	}
}

// Explore a given reachable state:
// (i) check whether it satisfies any of the specs.
// (ii) compute its successor states, and add them to the hash

void explore (wState *s)
{
	// restore s as current state and check the specs
	restore_state(s);
	for (expr *spec = global_specs; spec; spec = spec->next)
		if (eval(spec)) spec->sat = 1;

	// explore successors in all processes, save them to hash
	for (process *p = global_procs; p; p = p->next)
	{
		// restore s again (may have changed by previous iteration)
		restore_state(s);

		// process not terminated yet?
		if (!p->current) continue;

		switch (p->current->type)
		{
			// ASSIGN/SKIP: execute assignment + go to next stmt
			case ASSIGN:
				p->current->var->value = eval(p->current->expr);
			case SKIP:
				to_next(p);
				add_state();
				break;

			case BREAK:	// implement BREAK semantics
				do_break(p);
				add_state();
				break;

			case IF:	// find activated choices
			case DO:
				do_choices(p);
				break;
		}
	}
}

/****************************************************************************/

int main (int argc, char **argv)
{
	expr *spec;
	wState *s;
	int i;

	// parse the program
	if (argc <= 1) yyerror("no file specified");
	yyin = fopen(argv[1],"r");
	if (!yyin) yyerror("file not found");
	if (yyparse()) exit(1);
	fclose(yyin);

	// set up hash table with initial state
	hash = wHashCreate(cmp_states);
	add_state();

	// iteratively explore all reachable states
	while ((s = wHashPop(hash))) explore(s);

	// tell whether specs were satisfied or not
	for (i = 1, spec = global_specs; spec; i++, spec = spec->next)
		printf("property #%d is %ssatisfied\n",i,
			(spec->sat)? "" : "not ");
}
