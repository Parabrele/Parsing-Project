/***************************************************************************/
/*

   This file, along with langlex.l, are extensions of the TP's files found at https://lmf.cnrs.fr/IsaVialard/LangagesFormels.

   This program is our implementation of the level-3 objective, which involves exploring all reachable states and checking them against reachability specifications.
   
   It is written in Yacc/Bison, which is a tool for generating parsers and grammars. The grammar is in the file lang.y, and the lexical analyzer is in the file langlex.c. The lexical analyzer is generated by the tool Flex, which is a lexical analyzer generator.

   To compile the program, first run "make langlex.c" and then "make lang".

   The parsing (creation of the tree) is the first step.

*/
/***************************************************************************/

/****************************************************************************/
%{
//Definition of key structures and their initialization functions.
//The %{ and %} are used to include C code in the Bison file.
/****************************************************************************/

// Include necessary header files and declare external functions
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern int yylex();
extern int yylineno;

// Function to display error messages during parsing
// This function is part of the first amelioration mentioned in section 4 of the project description
void yyerror(char *s)
{
	fflush(stdout);
	fprintf(stderr, "%s at line %d\n",s,yylineno);
	exit(1);
}

// A structure for storing variables and their values as a linked list
typedef struct var
{
	char *name; // Variable name. Used to identify the variable wherever it is used in the program.
	long value; // Current value of the variable
	struct var *next; // Pointer to the next variable in the list
} var;

// A structure for storing expressions used in assignments, conds, and specs
typedef struct expr
{
	int type; // Operator type
	struct expr *left, *right; // Used to create a tree of expressions. For expressions with only one operand only the left pointer is used.
	int reached; // Reachability of the expression, initialized at 0. Used only for the reach expression.
	struct expr *next; // Pointer to the next expression in the list
} expr;

// A structure for storing sequences of statements
typedef struct statement
{
	int type; // Statement type (e.g. assignment, do, if, break, skip)
	var *var; // Variables used in the statement (exclusively for assignments)
	expr *expr; // Expression used in the statement (exclusively for assignments)
	struct choice *choice; // Pointer to a choice structure, used in do and if statements
	struct statement *up; // Pointer to the enclosing do or if statement
	struct statement *next; // Pointer to the next statement in the sequence
} statement;

// A structure for storing choices in a do or if statement
typedef struct choice
{
	expr *cond; // cond expression, if NULL then we go to the next choice
	struct statement *block; // Subordinate statements to be executed if the cond is true
	struct choice *next; // Pointer to the next choice in the list
} choice;

// A structure for storing each process in the program
typedef struct process
{
	char *name; // Process name. It will be used in the parsing section, when we will have to find how to chain the processes.
	var *locals; // Local variables
	struct statement *block; // Pointer to the first statement in the process
	struct statement *current; // Pointer to the current statement, for computing reachability
	struct process *next; // Pointer to the next process in the list
} process;

// All data pertaining to the program are accessible from these four vars.
var 	*global_vars; // Pointer to the list of global variables
var		*local_vars; // Pointer to the list of local variables. Used to initialize the local variables of each process on parsing.
process	*liveProcs; // Pointer to the list of processes
expr	*reachableSpecs; // Pointer to the list of expressions used in reachability specs

// To compute all reachable states, we need to know the size of a state in bytes,
// which includes space for the current statements of each process and for all variables.
int state_size = 0;

// Function to create a new variable
var* init_ident (char *s)
{
	var *v = malloc(sizeof(var)); // Allocate memory for the pointer to the new variable
	v->name = s;
	v->value = 0;	// All variables are initialized to 0
	v->next = NULL; // The new variable is added to the end of the list
	state_size += sizeof(v->value);
	return v;
}

// Function to find a variable in a given variable list
var* search_ident_in (char *s,var *varlist)
{
	while (varlist && strcmp(varlist->name,s)) varlist = varlist->next;
	return varlist;
}

// Function to find a variable in the global and local variable lists
var* search_ident (char *s)
{
	var *v = search_ident_in(s,local_vars);
	if (!v) v = search_ident_in(s,global_vars);
	if (!v) yyerror("variable not found");
	return v;
}

/* Initialization of useful structures to make the program run */

// Function to create a new process
// The process is added to the end of the list of processes
// This is usefull when several processes are defined in the same program
process* init_process (char *s, var *locals, statement *block)
{
	process *p = malloc(sizeof(process));
	p->name = s;
	p->locals = locals;
	p->block = block;
	p->current = block;
	p->next = NULL;
	state_size += sizeof(p->current);
	return p;
}

// Function to create a new expression
expr* init_expr (int type, expr *left, expr *right)
{
	expr *e = malloc(sizeof(expr));
	e->type = type;
	e->left = left;
	e->right = right;
	e->reached = 0;
	e->next = NULL;
	return e;
}

// Function to create a new choice
choice* init_choice (expr *cond, statement *block)
{
	choice *c = malloc(sizeof(choice));
	c->cond = cond;
	c->block = block;
	c->next = NULL;
	return c;
}

// Function to create a new statement
statement* init_statement (int type, var *var, expr *expr, choice *choice)
{
	statement *s = malloc(sizeof(statement));
	s->type = type;
	s->var = var;
	s->expr = expr;
	s->choice = choice;
	s->next = NULL;
	s->up = NULL;
	return s;
}

// This function is used to go back to the beggining of a statement block in a do or if.
// It follows the chain of statements and assign to each of them the pointer to the first statement.
// See semantic described in the 'next_statement' function, and the parsing behavior in the 'statement' rule for further information.
void set_up_statement (statement *block, statement *s)
{
	while (block) { block->up = s; block = block->next; }
}

// Function to set the "up" pointer of choices inside a DO/IF block
void set_up_choices (choice *c, statement *s)
{
	while (c) { set_up_statement(c->block,s); c = c->next; }
}

/****************************************************************************/
// End of useful structures initialization
%}
/****************************************************************************/

// I have no clue what this is for. But thanks to the TP for providing it c:
%union {
	char *c; // String
	long i; // Integer
	expr *e; // Expression
	statement *s; // Statement
	var *v; // Variable
	choice *x; // Choice
	process *p; // Process
}

%type <v> vars varlist
%type <e> expr specs
%type <s> statement statements
%type <x> choice choices
%type <p> procs process

// Define the terminals
%token VAR SKIP IF FI ELSE DO OD BREAK PROC END REACH
%token COND THEN ASSIGN EQ AND OR NOT
%token <i> INT
%token <c> IDENT

// Define the precedence and associativity of operators
%left ';'
%left EQ
%left '<' '>'
%left OR
%left AND
%left '+' '-'
%left '*'
%right NOT

/****************************************************************************/
%%
// The %% section is used to declare the rules of the grammar
// This defines the syntax of the language
/****************************************************************************/

// This part is extremely inspired by what was done in the TD.
start	: vars  { global_vars = $1; } // When parsing starts, we first define the variables (if any)
	  procs { liveProcs = $3; local_vars = NULL; } // Then proceed with the processes
	  specs { reachableSpecs = $5; } // Finally, add specifications (if any) that will have to be checked for reachability

vars	: { $$ = NULL; } // Initial case: No variables
	| VAR varlist ';' vars // Variables in the following format VAR ident1, ident2 ... ;
	  {
		var *tmp = $2;
		while (tmp->next) tmp = tmp->next;
		tmp->next = $4;
		$$ = $2;
	  }
		
varlist	: IDENT			{ $$ = init_ident($1); } // List of variable identifiers
	| varlist ',' IDENT	{ ($$ = init_ident($3))->next = $1; }

// The _s rules are used to define sequences of _. Specifically, a sequence of processes, statements or choices.
procs	: process // Initial case: one process
	| procs process		{ ($$ = $2)->next = $1; } // Add more processes in a chained list

process : PROC IDENT vars	{ local_vars = $3; } // Start with process name and variables
	  statements END		{ $$ = init_process($2,local_vars,$5); } // End with the process statement

statements	: statement // The statement can be alone
	| statement ';' statements	{ ($$ = $1)->next = $3; } // Or multiple statements separated by SEMICOLON

// Makes a new statement with the given type, variable, expression and choice
statement	: IDENT ASSIGN expr //Assignment statement
		{ $$ = init_statement(ASSIGN,search_ident($1),$3,NULL); }
	// See the semantic described in the 'next_statement' function to understand the following lines
	| DO choices OD //DO clause
		{ $$ = init_statement(DO,NULL,NULL,$2); set_up_choices($2,$$); }
	| IF choices FI //IF clause
		{ $$ = init_statement(IF,NULL,NULL,$2); set_up_choices($2,$$); }
	| BREAK //Break clause
		{ $$ = init_statement(BREAK,NULL,NULL,NULL); }
	| SKIP //Skip clause
		{ $$ = init_statement(SKIP,NULL,NULL,NULL); }

choices	: choice // The choice can be one choice statement
	| choice choices // Or more than one choice statement
		{ ($$ = $1)->next = $2;
		  // if there is no cond specified, then this is an ELSE case and it must be the last choice
		  if ($1->cond == NULL && $2 != NULL)
			yyerror("The ELSE statement must be the last choice in DO/IF");
		}
/* Choice syntax :
 * :: condition -> block
*/
choice	: COND expr THEN statements	{ $$ = init_choice($2,$4); } // Choice with cond
	| COND ELSE THEN statements	{ $$ = init_choice(NULL,$4); } // Choice without cond. They are the else statements.

// Makes an expression tree. Expressions are made of arithmetic and boolean operators applied to variables and constants.
expr	: IDENT		{ $$ = init_expr(IDENT,(expr*)search_ident($1),NULL); } // Variable
	| INT			{ $$ = init_expr(INT,(expr*)$1,NULL); } // Integer
	| expr '+' expr	{ $$ = init_expr('+',$1,$3); } // Add expression
	| expr '-' expr	{ $$ = init_expr('-',$1,$3); } // Subtraction expression
	| expr '*' expr	{ $$ = init_expr('*',$1,$3); } // Multiplication expression
	| expr '<' expr	{ $$ = init_expr('<',$1,$3); } // Less than expression
	| expr '>' expr	{ $$ = init_expr('>',$1,$3); } // Greater than expression
	| expr EQ expr	{ $$ = init_expr(EQ,$1,$3); } // Equality expression
	| NOT expr		{ $$ = init_expr(NOT,$2,NULL); } // Negative expression
	| expr AND expr	{ $$ = init_expr(AND,$1,$3); } // AND expression
	| expr OR expr	{ $$ = init_expr(OR,$1,$3); } // OR expression
	| '(' expr ')'	{ $$ = $2; } // Parenthetical expression

specs	: 			{ $$ = NULL; } // Initial case: No specifications
	| REACH expr specs	{ ($$ = $2)->next = $3; } // Add Reachability Specifications


/****************************************************************************/
// End of the %% section. This is it for the syntax of the language.
%%
/****************************************************************************/
// Now, the semantics of the language.

// lexing file
#include "langlex.c"
// hash table implementation
#include "hash.c"
// CRC-32 hash function implementation
#include "crc32.c"

/* Interface with hash table: saving and restoring states */

wHash *hash;

// The hashtable needs a function to order the states, and here it is.
int wStateCmp (wState* state1, wState* state2)
{
	return memcmp(state1->memory, state2->memory, state_size);
}

// Function used to save a state whenever it is added to the hash.
void save_state (void **mem, void *ptr, int size)
{
	memcpy(*mem,ptr,size);
	*mem += size;
}

// Creation of a new state from the current one, and insertion into the hash table if it is not already visited.
void add_current_state ()
{
	// generate the new structure to be inserted in the hash table
	wState *s = malloc(sizeof(wState));
	// The state_size is dinamically updated depending on the local variables.
	s->memory = malloc(state_size);

	// Copy the current state into the new structure
	void *tmp = s->memory;
	for (process *p = liveProcs; p; p = p->next)
	{
		// /!\ p->current is a pointer to the current statement, not state !
		// This is why in the save/restore function there is a difference in the treatment of mem and ptr, and their order matters.
		save_state(&tmp,&(p->current),sizeof(process*));
		for (var *v = p->locals; v; v = v->next)
		{
			save_state(&tmp,&(v->value),sizeof(long));
		}
	}
	for (var *v = global_vars; v; v = v->next)
	{
		save_state(&tmp,&(v->value),sizeof(long));
	}

	s->hash = xcrc32(s->memory,state_size,0x5F5E125); // just a random prime number

	// check whether state already known, free memory if so
	wState *t = wHashInsert(hash,s);
	if (s == t) return;
	free(s->memory);
	free(s);
}

// Restore current state from hashed state.
void save_inverse (void **mem, void *ptr, int size)
{
	memcpy(ptr,*mem,size);
	*mem += size;
}

void restore_state (wState *s)
{
	void *tmp = s->memory;
	for (process *p = liveProcs; p; p = p->next)
	{
		save_inverse(&tmp,&(p->current),sizeof(process*));
		for (var *v = p->locals; v; v = v->next)
			save_inverse(&tmp,&(v->value),sizeof(long));
	}
	for (var *v = global_vars; v; v = v->next)
		save_inverse(&tmp,&(v->value),sizeof(long));
}

// evaluate an arithmetic expression, used in assign/cond/spec.
int eval_expr (expr *e)
{
	switch (e->type)
	{
		case OR: return eval_expr(e->left) || eval_expr(e->right);
		case AND: return eval_expr(e->left) && eval_expr(e->right);
		case NOT: return !eval_expr(e->left);
		case EQ: return eval_expr(e->left) == eval_expr(e->right);
		case '<': return eval_expr(e->left) < eval_expr(e->right);
		case '>': return eval_expr(e->left) > eval_expr(e->right);
		case '+': return eval_expr(e->left) + eval_expr(e->right);
		case '*': return eval_expr(e->left) * eval_expr(e->right);
		case '-': return eval_expr(e->left) - eval_expr(e->right);
		case IDENT: return ((var*)(e->left))->value;
		case INT: return (long)(e->left);
	}
}

// Find the next statement to execute in the process p, and update p->current accordingly.
// If there is no next statement, p->current is set to NULL and the process is terminated.
void next_statement (process *p)
{
	/*
	 * If the current statement has a successor, simply go to it.
	 * Otherwise, go to the up statement.
	 * 		If it is null, it means that we broke a process, and said process is terminated.
	 * 		Otherwise, if it was a DO, we want to do the do again, so we are happy with it being the current statement.
	 * 		Otherwise, we go up the if chain until we find either an if that has a successor statement, a do, or we reach the top.
	*/

	//REMONTER LES IF MAIS PAS LES DO !!!
	while (p->current && !p->current->next && p->current->type != DO) {
		p->current = p->current->up;
	};
	
	// p->current is now NULL/DO/other
	// if NULL, p is terminated
	if (!p->current) return;
	// if DO, then do it again
	if (p->current->type == DO) return;
	// if we just exited an IF, or simply there is a next statement, go to it
	p->current = p->current->next;
}

// given a reachable state, check for satisfied specs and compute successors states (also reachable) to be explored later by adding them to the hash
void explore (wState *s)
{
	// restore s as the current state and check the specs satisfied
	restore_state(s);
	for (expr *spec = reachableSpecs; spec; spec = spec->next)
		if (eval_expr(spec)) spec->reached = 1;

	// explore successor states in all processes, and save them to hash
	for (process *p = liveProcs; p; p = p->next)
	{
		// restore s as the current state as it may have been modified by another itteration of the loop
		restore_state(s);

		// if p is terminated, skip
		if (!p->current) continue;
		// We simply do what the current statement wants us to do and call the add_current_state function to save the state.
		// That way, if the statement changed the state in any way, it will be a reachable state we will have to explore it if not already done.
		switch (p->current->type)
		{
			// ASSIGN : evaluate the expression and go to next statement
			case ASSIGN:
				p->current->var->value = eval_expr(p->current->expr);
				next_statement(p);
				add_current_state();
				break;
			// SKIP : go to next statement and add the state to the hash
			case SKIP:
				next_statement(p);
				add_current_state();
				break;
			// BREAK : find nearest including DO structure, and go out of it. If there is no DO structure, p is terminated.
			case BREAK:
				// find nearest including DO structure
				while (p->current && p->current->type != DO)
					p->current = p->current->up;

				// if current is NULL, then we broke out of a DO structure and p is terminated
				if (p->current)
				{
				// otherwise, get out of the DO through 'next' or 'up' statement
				if (p->current->next)
					{ p->current = p->current->next; }
				else {
					p->current = p->current->up;
					next_statement(p);
				}
				}
				add_current_state();
				break;
			// IF/DO : same as BREAK but we have to go through all possible choices, and we don't add the state to the hash here.
			// This is the only source of non-determinism in the program.
			// The non determinism comes from the fact that guards values might change based on the order the processes are executed.
			// Note : this is also why before every process in this loop, we restore the state to the one we are currently exploring.
			//		  This way, all possible order of execution between the processes are explored.
			case IF:
			case DO:
				int esle = 1;	// always takes the ELSE branch unless another cond is true

				// This loop will execute every choice whose cond is evaluated to true.
				for (choice *c = p->current->choice; c; c = c->next)
				{
					// if there is no condition and this is not an ELSE, then skip.
					if (!c->cond && !esle) continue;
					// Otherwise, if there is a condition and it is not satisfied, skip.
					if (c->cond && !eval_expr(c->cond)) continue;
					// Otherwise, the condition is satisfied and we remember that we want to explore the current block, but not the else case.
					p->current = c->block;
					add_current_state();
					esle = 0;
				}
				break;
		}
	}
}

int main (int argc, char **argv)
{
	expr *spec;
	wState *s;
	int i;

	// parse the program
	if (argc <= 1) yyerror("please specify a file name");
	yyin = fopen(argv[1],"r");
	if (!yyin) yyerror("invalid file name");
	if (yyparse()) exit(1);
	fclose(yyin);

	// set up hash table with initial state
	hash = wHashCreate(wStateCmp);
	add_current_state();

	// iteratively explore all reachable states
	// Given a state, explore it and add all its successors to be explored later.
	while ((s = wHashPop(hash))) explore(s);

	// tell whether specs were reached or not. As spec->reached is set to 1 when satisfied, and never reset to 0, we can just check this value.
	for (i = 1, spec = reachableSpecs; spec; i++, spec = spec->next)
		printf("specification n°%d is %sreachable\n",i,
			(spec->reached)? "" : "not ");
}
